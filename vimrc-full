" Expedite:    provides helpful movement keys to affect the surroundings of text {{{
  Plugin 'tpope/vim-surround'
" }}}
" Expedite:    allows to easily and precisely jump to a location {{{
  Plugin 'Lokaltog/vim-easymotion'
" }}}
" Expedite:    adds more text objects to quickly modify the text {{{
  Plugin 'kana/vim-textobj-user'

  " indentations: i
  Plugin 'austintaylor/vim-indentobject'

  " " symbols: :
  " Plugin 'bootleq/vim-textobj-rubysymbol'

  " vertical columns by word boundary: c
  Plugin 'coderifous/textobj-word-column.vim'

  " " functions: f - does not support ruby/python/php by default
  " Plugin 'kana/vim-textobj-function'

  " " ruby blocks: r - works nearly same as indentobject
  " Plugin 'nelstrom/vim-textobj-rubyblock'

  " arguments: z
  Plugin 'kana/vim-textobj-fold'
" }}}
" Specialize:  supports multiple cursors for editing text in one go {{{
  Plugin 'terryma/vim-multiple-cursors'
  let g:multi_cursor_use_default_mapping = 0
  let g:multi_cursor_next_key='<F3>'
  let g:multi_cursor_prev_key=''
  let g:multi_cursor_skip_key=''
  let g:multi_cursor_quit_key='<Esc>'
" }}}
" Specialize:  allows focussing on a narrow region of the text {{{
  Plugin 'chrisbra/NrrwRgn'
  " remove highlighting for narrow region
  let g:nrrw_rgn_nohl = 1

  " TODO: implement a function that selects lines based on regex and opens a NRW
  " TODO: Open the current fold in a narrow region
  " nmap <leader>nf <esc><space>zRvaz<leader>nr<C-W>T<leader>f9
" }}}
" Expected:    restore cursor after joining lines {{{
  nnoremap J mjJ`j
" }}}
" Recommended: quickly get out of insert mode using 'jj' or 'jk' keys {{{
  inoremap jj <Esc>
  inoremap jk <Esc>
" }}}
" Expected:    visual shifting (does not exit Visual mode when shifting text) {{{
  vnoremap < <gv
  vnoremap > >gv
" }}}
" Mappings:    view changes in the current buffer as a diff {{{
  " Function: View changes in the current buffer {{{
  function! DiffWithSaved()
    let filetype=&ft
    diffthis
    vnew | r # | normal! 1Gdd
    diffthis
    exe "setlocal bt=nofile bh=wipe nobl noswf ro ft=" . filetype
  endfunction " }}}
  nnoremap <leader>ds :call DiffWithSaved()<CR>
" }}}
" Mappings:    quickly edit files in the current directory {{{
  map <leader>er :e **/*
  map <leader>ew :e ./
  map <leader>es :sp ./
  map <leader>ev :vsp ./
  map <leader>et :tabe ./
" }}}
" Mappings:    use Q for formatting the current paragraph (or visual selection) {{{
  vmap Q gq
  nmap Q gqap
" }}}
" Mappings:    auto-indent the entire document, and jump back to current location {{{
  nmap <leader>b= ggVG=''
" }}}
" Mappings:    insert the current time by pressing <F8> {{{
  nnoremap <F8> "=strftime("%d-%m-%y %H:%M:%S")<CR>P
  inoremap <F8> <C-R>=strftime("%d-%m-%y %H:%M:%S")<CR>
" }}}
" Mappings:    allows to quickly complete file names in insert mode {{{
  imap <C-f> <C-x><C-f>
" }}}
" Mappings:    allows to quickly complete lines from current buffer in insert mode {{{
  imap <C-l> <C-x><C-l>
" }}}
" }}}
" Mappings:                                                          {{{
" NOTE: This section does not cover all the mappings for the editor. Most
" mappings are defined along with the relevant feature set.
" Recommend:   swaps generic most used key mappings with analogous mappings {{{
  " Since I never use the ; key anyway, this is a real optimization for almost
  " all Vim commands, since we don't have to press that annoying Shift key that
  " slows the commands down
  nnoremap ; :
  " nnoremap : ;    " not recommended

  " Swap implementations of ` and ' jump to markers
  nnoremap ' `
  nnoremap ` '

  " Swap implementations of 0 and ^
  nnoremap 0 ^
  nnoremap ^ 0
" }}}
" Recommend:   avoids any accidental hits with mappings {{{
  " avoid accidental hits of <F1> while aiming for <Esc>
  noremap  <F1> :echom "Use ". &keywordprg ." OR press 'K' to get help."<CR><Esc>
  noremap! <F1> <Esc>:echom "Use ". &keywordprg ." OR press 'K' to get help."<CR><Esc>a

  " avoid accidental hits of Shift key
  cmap Tabe tabe
  if has("user_commands")
    command! -bang -nargs=* -complete=file E e<bang> <args>
    command! -bang -nargs=* -complete=file W w<bang> <args>
    command! -bang -nargs=* -complete=file Wq wq<bang> <args>
    command! -bang -nargs=* -complete=file WQ wq<bang> <args>
    command! -bang Wa wa<bang>
    command! -bang WA wa<bang>
    command! -bang Q q<bang>
    command! -bang QA qa<bang>
    command! -bang Qa qa<bang>
  endif
" }}}
" Recommend:   has mappings to perform everyday tasks quicker {{{
  " quickly close the current window
  noremap <leader>wq :q<CR>

  " quick save a file
  nnoremap <leader>fs :w!<CR>

  " sudo to write
  cmap w!! w !sudo tee % >/dev/null

  " Switch between the last two files
  nnoremap <leader><leader> <C-^>
" }}}
" Recommend:   provides some easier movement related mappings {{{
  " remap j and k to act as expected when used on long, wrapped, lines
  noremap j gj
  noremap k gk

  " jump to matching pairs easily, with Tab
  nnoremap <Tab> %
  vnoremap <Tab> %

" }}}
" Recommend:   provides a mapping to save file after removing all trailing whitespace {{{
  " replaces all hard tabs and ^M to spaces, and then removes trailing WS.
  " restores cursor position by setting a marker
  nnoremap <silent> <leader>W  mw:%s/\v<C-v><C-m>//e<CR>:retab<CR>:%s/\s\+$//e<CR>:nohlsearch<CR>:w<CR>`w
" }}}
" Recommend:   provides standard OS shortcuts on MacOSX {{{
if g:is_mac

  " indentation related
  omap <D-]> >>
  omap <D-[> <<
  nmap <D-]> >>
  nmap <D-[> <<
  vmap <D-]> >gv
  vmap <D-[> <gv
  imap <D-]> <Esc>>>i
  imap <D-[> <Esc><<i

  " bubble lines up/down
  nmap <D-k> [e
  nmap <D-j> ]e
  vmap <D-k> [egv
  vmap <D-j> ]egv

  " map Command-# to switch tabs
  map  <D-0> 0gt
  imap <D-0> <Esc>0gt
  map  <D-1> 1gt
  imap <D-1> <Esc>1gt
  map  <D-2> 2gt
  imap <D-2> <Esc>2gt
  map  <D-3> 3gt
  imap <D-3> <Esc>3gt
  map  <D-4> 4gt
  imap <D-4> <Esc>4gt
  map  <D-5> 5gt
  imap <D-5> <Esc>5gt
  map  <D-6> 6gt
  imap <D-6> <Esc>6gt
  map  <D-7> 7gt
  imap <D-7> <Esc>7gt
  map  <D-8> 8gt
  imap <D-8> <Esc>8gt
  map  <D-9> 9gt
  imap <D-9> <Esc>9gt
endif
" }}}
" }}}
" Programming:                                                       {{{
" Personalize: considers '.', '-', & '#' characters as part of the keyword {{{
  set iskeyword-=.
  set iskeyword-=#
  set iskeyword-=-
" }}}
" Personalize: display informative text when code is folded {{{
  " Function: Text to display on folded lines {{{
  function! MyFoldText()
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount) - 4
    return line . ' ' . repeat("-",fillcharcount) . ' ' . foldedlinecount . ' '
  endfunction " }}}
  set foldtext=MyFoldText()       " function for text that appears over folds
" }}}
" Essential:   enables sane syntax highlighting of code, whenever possible {{{
  set synmaxcol=800    " don't try to highlight lines longer than 800 characters
  " syntax highlight on, when terminal has colors
  if g:is_gui || &t_Co > 2 | syntax on | endif
" }}}
" Expected:    briefly blinks matching paranthesis for quick orientation {{{
  set showmatch                   " set show matching parenthesis
  set matchtime=2                 " show matching parenthesis for 0.2 seconds
" }}}
" Expected:    automatically, indents code when editing code {{{
  set autoindent                  " always set autoindenting on
  set shiftwidth=2                " number of spaces to use for autoindenting
  set copyindent                  " copy the previous indentation on autoindenting
  set shiftround                  " use multiple of 'sw' when indenting with '<' and '>'
  set smarttab                    " insert tabs on start of line acc to 'sw' not 'ts'
" }}}
" Expected:    has support for code folding (default: based on indentation) {{{
  set nofoldenable                " do not enable folding, by default
  set foldcolumn=0                " add a fold column to the left of line-numbers
  set foldlevel=0                 " folds with a higher level will be closed
  set foldlevelstart=10           " start out with everything open
  set foldmethod=indent           " create folds based on indentation
  set foldnestmax=7               " deepest fold is 7 levels
  set foldminlines=1              " do not fold single lines, fold everything else
  " which commands trigger auto-unfold
  set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo
" }}}
" Expected:    auto-formats comments, & insert comment markers where required {{{
  " automatically, insert comment marker, when possible:
  set formatoptions+=cro
  " allow 'gq' to format comments
  set formatoptions+=q
  " remove comment markers when joining lines
  silent! set formatoptions+=j    " gives error on some versions of vim 7.3 & lower
" }}}
" Expedite:    supports adding or removing comments for many languages {{{
  Plugin 'tpope/vim-commentary'
  " From the FAQ:
  " > My favorite file type isn't supported!
  " > > Relax! You just have to adjust 'commentstring':
  "     autocmd FileType apache set commentstring=#\ %s
" }}}
" Expedite:    adds block-level end statements when hitting Enter key {{{
  Plugin 'tpope/vim-endwise'
" }}}
" Expedite:    adds or removes punctuation pairs when typing, smartly {{{
  Plugin 'kana/vim-smartinput'
" }}}
" Expedite:    Mapping: toggle fold on the current fold using a space {{{
  nnoremap <Space> za
  vnoremap <Space> za
" }}}
" Specialize:  allows switching between alternate forms of code segments {{{
  "
  " Example:
  " let's say, you've a simple ruby code:
  "   hash = { x: 'something', y: 'something-else' }
  " hitting '-' key, while the cursor is on 'x', will produce:
  "   hash = { :x => 'something', y: 'something-else' }
  "
  Plugin 'AndrewRadev/switch.vim'
  nnoremap - :Switch<cr>
" }}}
" Specialize:  provides a way to quickly align code segments {{{
  Plugin 'tsaleh/vim-align'
" }}}
" Advanced:    loads tag file when found, and adds some convenient mappings {{{
  set tags+=./tags,tags;/         " find and load tags file up until root
  " Plugin 'ludovicchabant/vim-gutentags'
  " let g:gutentags_cache_dir = '~/.tags_cache'

  " mappings:
  " TODO: what does this correspond to?
  nnoremap <silent> <leader>j :tnext<cr>zt
  nnoremap <silent> <leader>J :tprev<cr>zt
  nnoremap <silent> <leader>k :pop<cr>zt
  map <C-\> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>
  map <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
" }}}
" Mappings:    allows to quickly fold text at a specific level {{{
  nmap <leader>f0 :set foldlevel=0<CR>
  nmap <leader>f1 :set foldlevel=1<CR>
  nmap <leader>f2 :set foldlevel=2<CR>
  nmap <leader>f3 :set foldlevel=3<CR>
  nmap <leader>f4 :set foldlevel=4<CR>
  nmap <leader>f5 :set foldlevel=5<CR>
  nmap <leader>f6 :set foldlevel=6<CR>
  nmap <leader>f7 :set foldlevel=7<CR>
  nmap <leader>f8 :set foldlevel=8<CR>
  nmap <leader>f9 :set foldlevel=9<CR>
" }}}
" Tweak:       doesn't screw up folds when inserting text {{{
  " Don't screw up folds when inserting text that might affect them, until
  " leaving insert mode. Foldmethod is local to the window. Protect against
  " screwing up folding when switching between windows.
  " http://vim.wikia.com/wiki/Keep_folds_closed_while_inserting_text
  augroup FixFoldInsert
    au!
    autocmd InsertEnter * if !exists('w:last_fdm') | let w:last_fdm=&foldmethod |
                        \ setlocal foldmethod=manual | endif
    autocmd InsertLeave,WinLeave * if exists('w:last_fdm') |
                                \ let &l:foldmethod=w:last_fdm |
                                \ unlet w:last_fdm | endif
  augroup end
" }}}
" Essential:   supports SYNTAX highlighting , FileType detection, etc. for many languages {{{
  Plugin 'vim-scripts/SyntaxRange'

  " text markup family:
  " Plugin 'tpope/vim-markdown'             " mardown | #TODO: required?
  Plugin 'jtratner/vim-flavored-markdown' " Github flavored markdown syntax
  Plugin 'timcharper/textile.vim'         " textile markup

  " html & css family:
  Plugin 'othree/html5.vim'               " html 5
  Plugin 'hail2u/vim-css3-syntax'         " CSS3
  Plugin 'groenewege/vim-less'            " Less
  Plugin 'cakebaker/scss-syntax.vim'      " SCSS
  Plugin 'tpope/vim-haml'                 " haml, sass and scss
  Plugin 'mustache/vim-mustache-handlebars'

  " javascript family:
  Plugin 'pangloss/vim-javascript'        " Javascript
  Plugin 'mxw/vim-jsx'
  Plugin 'kchmck/vim-coffee-script'       " Coffeescript
  Plugin 'itspriddle/vim-jquery'          " jQuery
  Plugin 'mmalecki/vim-node.js'           " Node.js

  " php
  Plugin 'spf13/PIV'                      " PHP integrated environment

  "python
  " Python integrated environment
  " adds support for linting, doc search, execution, debugging, code completion, etc.
  Plugin 'klen/python-mode'

  " ruby
  Plugin 'vim-ruby/vim-ruby'
  Plugin 'tpope/vim-rbenv'
  Plugin 'tpope/vim-rails'
  Plugin 'tpope/vim-rake'
  Plugin 'thoughtbot/vim-rspec'

  " NOTE: `vim-bundler` uses 2 system commands that are expensive.
  "       Therefore, we replace it with autocmds instead. Look into:
  "       " Ruby: Rails: persist ctags when we move inside gem directories
  "
  " Plugin 'tpope/vim-bundler'
  "
  " ' system('ruby -rubygems -e "print Gem.path.join(%(;))"')
  " ' system('ruby -rrbconfig -e "print RbConfig::CONFIG[\"ruby_version\"]"')

  " go
  Plugin 'fatih/vim-go'
  let g:go_highlight_operators = 1
  let g:go_highlight_functions = 1
  let g:go_highlight_methods = 1
  let g:go_highlight_structs = 1

  " miscelleneous:
  Plugin 'csv.vim'                        " CSV files
" }}}
" Essential:   supports language-specific CODE COMPLETION for many languages {{{

  set completeopt+=menu,longest     " select first item, follow typing in autocomplete
  set complete=.,w,b,u,t            " do lots of scanning on tab completion,  FIXME?
  set pumheight=6                   " Keep a small completion window

  " For snippet_complete marker.
  if has('conceal')
    set conceallevel=2 concealcursor=i
  endif

  set completeopt+=preview          " enable doc preview in omnicomplete
  " Disable the neosnippet preview candidate window
  " When enabled, there can be too much visual noise
  " especially when splits are used.
  " set completeopt-=preview

  " php
  Plugin 'shawncplus/phpcomplete.vim'

  " Plugin 'Valloric/YouCompleteMe'
  " " enable completion from tags
  " let g:ycm_collect_identifiers_from_tags_files = 1
  " " enable completion for keywords in current language
  " let g:ycm_seed_identifiers_with_syntax = 0

  " if has('lua')
  "   Plugin 'Shougo/neocomplete.vim'
  "   let g:neocomplete#enable_at_startup = 1                 " enable at startup
  "   let g:neocomplete#enable_ignore_case = 1                " ignore case when completing
  "   let g:neocomplete#sources#syntax#min_keyword_length = 4 " use a minimum syntax keyword length
  "   let g:neocomplete#force_overwrite_completefunc = 1
  "   " do not complete automatically on files matching this pattern
  "   " let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
  "   " let g:neocomplete#keyword_patterns['default'] = '\h\w*'
  "   inoremap <expr><C-g>     neocomplete#undo_completion()
  "   inoremap <expr><C-l>     neocomplete#complete_common_string()

  "   " <CR>: close popup and save indent.
  "   inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
  "   function! s:my_cr_function()
  "     return neocomplete#smart_close_popup() . "\<CR>"
  "     " For no inserting <CR> key.
  "     "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
  "   endfunction

  "   " <TAB>: completion.
  "   inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"

  "   " <C-h>, <BS>: close popup and delete backword char.
  "   inoremap <expr><C-h>  neocomplete#smart_close_popup()."\<C-h>"
  "   inoremap <expr><BS>   neocomplete#smart_close_popup()."\<C-h>"
  "   inoremap <expr><C-y>  neocomplete#close_popup()
  "   inoremap <expr><C-e>  neocomplete#cancel_popup()
  " else
  "   Plugin 'Shougo/neocomplcache.vim'
  "   let g:neocomplcache_enable_at_startup  = 1               " enable at startup
  "   let g:neocomplcache_enable_ignore_case = 1               " ignore case when completing
  "   let g:neocomplcache_min_syntax_length  = 4               " use a minimum syntax keyword length
  "   " do not complete automatically on files matching this pattern
  "   " let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'
  "   " if !exists('g:neocomplcache_keyword_patterns')
  "     " let g:neocomplcache_keyword_patterns = {}
  "   " endif
  "   " let g:neocomplcache_keyword_patterns['default'] = '\h\w*'
  "   inoremap <expr><C-g>     neocomplcache#undo_completion()
  "   inoremap <expr><C-l>     neocomplcache#complete_common_string()

  "   " <CR>: close popup and save indent.
  "   inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
  "   function! s:my_cr_function()
  "     return neocomplcache#smart_close_popup() . "\<CR>"
  "     " For no inserting <CR> key.
  "     "return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
  "   endfunction

  "   " <TAB>: completion.
  "   inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"

  "   " <C-h>, <BS>: close popup and delete backword char.
  "   inoremap <expr><C-h>  neocomplcache#smart_close_popup()."\<C-h>"
  "   inoremap <expr><BS>   neocomplcache#smart_close_popup()."\<C-h>"
  "   inoremap <expr><C-y>  neocomplcache#close_popup()
  "   inoremap <expr><C-e>  neocomplcache#cancel_popup()
  " endif

  " Enable omni completion.
  augroup omni_complete
    au!
    if exists('+omnifunc')
      " Enable omni completion for filetypes (Ctrl-X Ctrl-O)
      autocmd filetype html,ghmarkdown setlocal omnifunc=htmlcomplete#CompleteTags
      autocmd filetype javascript setlocal omnifunc=javascriptcomplete#CompleteJS
      autocmd filetype python setlocal omnifunc=pythoncomplete#Complete
      autocmd filetype xml setlocal omnifunc=xmlcomplete#CompleteTags
      autocmd filetype c setlocal omnifunc=ccomplete#Complete
      autocmd filetype css setlocal omnifunc=csscomplete#CompleteCSS
      autocmd filetype java setlocal omnifunc=javacomplete#Complete
      autocmd filetype xml setlocal omnifunc=xmlcomplete#CompleteTags
      autocmd filetype haskell setlocal omnifunc=necoghc#omnifunc
      autocmd filetype ruby setlocal omnifunc=rubycomplete#Complete

      " use syntax complete if nothing else available
      autocmd filetype * if &omnifunc == '' | setlocal omnifunc=syntaxcomplete#Complete | endif
    endif
  augroup end

  " ruby - required by rails.vim
  augroup omni_complete_ruby
    au!
    autocmd filetype ruby,eruby let g:rubycomplete_buffer_loading = 1
    autocmd filetype ruby,eruby let g:rubycomplete_rails = 1
    autocmd filetype ruby,eruby let g:rubycomplete_classes_in_global = 1
    autocmd filetype ruby,eruby let g:rubycomplete_include_object = 1
    autocmd filetype ruby,eruby let g:rubycomplete_include_objectspace = 1
  augroup end
" }}}
" Essential:   supports snippets for many languages {{{
  Plugin 'Shougo/neosnippet'
  Plugin 'honza/vim-snippets'
  Plugin 'Shougo/neosnippet-snippets'

  noremap <leader>nse :NeoSnippetEdit -vertical -split -direction=belowright<CR>

  " Enable snipMate compatibility feature.
  let g:neosnippet#enable_snipmate_compatibility = 1
  " tell NeoSnippet about other snippets
  let g:neosnippet#snippets_directory = [
        \ expand('~/.vim') . '/bundle/vim-snippets/snippets',
        \ expand('~/.vim') . '/data/snippets' ]

  imap <C-k>     <Plug>(neosnippet_expand_or_jump)
  smap <C-k>     <Plug>(neosnippet_expand_or_jump)
  xmap <C-k>     <Plug>(neosnippet_expand_target)

  " SuperTab like snippets behavior.
  imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
    \ "\<Plug>(neosnippet_expand_or_jump)"
    \ : pumvisible() ? "\<C-n>" : "\<TAB>"
  smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
    \ "\<Plug>(neosnippet_expand_or_jump)"
    \ : "\<TAB>"
" }}}
" Essential:   properly detects filetype for weird files or corrects them and adds syntax {{{
  " Plugin 'sheerun/vim-polyglot'
  augroup detect_filetypes
    au!
    " html & css family:
    au BufNewFile,BufRead *.less setl ft=less
    au BufNewFile,BufRead *.scss setl ft=scss
    au BufNewFile,BufRead *.sass setl ft=sass
    " javascript family:
    au BufNewFile,BufRead *.json setl ft=json
    au BufNewFile,BufRead *.coffee{,script} setl ft=coffee
    " ruby:
    au BufNewFile,BufRead Rakefile,Capfile,Gemfile,Guardfile,Vagrantfile
          \,Thorfile,Do,dorc,Dofile,config.ru,.autotest,.irbrc,.pryrc
          \,.simplecov,*.thor,*.rabl setl ft=ruby
    " vim and shell files:
    au BufNewFile,BufRead *vimrc,*.vim setl ft=vim
    au BufNewFile,BufRead *zshrc,*zprofile,*zlogout,*zlogin,*zshenv,*.zsh-theme setl ft=sh
    " text files
    au BufNewFile,BufRead *.md,*.mdown,*.markdown setl ft=ghmarkdown
    " messes help text files
    " au BufNewFile,BufRead *.txt,*.text setl ft=text
    " php files
    au BufNewFile,BufRead *.ctp setl ft=ctp
    " go
    au BufNewFile,BufRead *.go setl ft=go
    " elixir
    au BufNewFile,BufRead *.ex,*.exs setl ft=elixir
    au BufNewFile,BufRead *.html.eex setl ft=html
    " miscelleneous
    au BufNewFile,BufRead gemrc,*.yml,*.yaml setl ft=yaml
  augroup end

  augroup riot_js
    au!
    au BufNewFile,BufRead *.js.tag setl ft=html
    au filetype html :call SyntaxRange#Include("<style>", "</style>", "css")
    au filetype html :call SyntaxRange#Include("<style.*sass.*>", "</style>", "scss")
    au filetype html :call SyntaxRange#Include("<style.*scss.*>", "</style>", "scss")
    au filetype html :call SyntaxRange#Include("<style.*less.*>", "</style>", "less")
    au filetype html :call SyntaxRange#Include("<script>", "</script>", "javascript")
    au filetype html :call SyntaxRange#Include("<script.*coffee.>", "</script>", "coffee")
    au filetype html :call SyntaxRange#Include("<script.*coffeescript.>", "</script>", "coffee")
  augroup END
" }}}
" Essential:   sets up a sane editing/coding environment as per the filetype {{{
  augroup setup_environment
    au!
    au filetype html,xhtml,haml         setl ts=2 sw=2 sts=2 tw=0  et
    au filetype css,less,sass,scss      setl ts=2 sw=2 sts=2 tw=80 et
    au filetype json,javascript,coffee  setl ts=2 sw=2 sts=2 tw=80 et
    au filetype python                  setl ts=4 sw=4 sts=4 tw=80 et
    au filetype ruby,eruby              setl ts=2 sw=2 sts=2 tw=80 et
    au filetype php,ctp                 setl ts=4 sw=4 sts=4 tw=80 et
    au filetype sh,zsh,bash,vim         setl ts=2 sw=2 sts=2 tw=72 et
    au filetype ghmarkdown,textile      setl ts=4 sw=4 sts=4 tw=72 et
    au filetype rst                     setl ts=4 sw=4 sts=4 tw=74 et
    au filetype yaml                    setl ts=2 sw=2 sts=2 tw=72 et
    au filetype make                    setl noet " make uses real tabs
  augroup end
" }}}
" Essential:   sets up folding for the current file as per its filetype {{{
  augroup create_folds
    au!
    au filetype css,less,sass,scss setl fdm=marker fmr={,}
    au filetype coffee             setl fdm=indent fdls=1
    au filetype javascript         setl fdm=syntax fdls=1
    au filetype ruby,eruby         setl fdm=syntax
    au filetype sh,zsh,bash,vim    setl fdm=marker fmr={{{,}}} fdls=0 fdl=0
    au filetype yaml,conf          setl fdm=marker fmr={{{,}}} fdls=0 fdl=0
  augroup end
" }}}
" Essential:   sets up syntax as per the filetype or other variables {{{
  augroup syntax_higlighting
    au!
    au filetype json,javascript    setl syntax=javascript
    au filetype ctp                setl syntax=php
    " javascript syntax should be enhanced via jquery syntax
    au syntax   javascript         setl syntax=jquery
  augroup end
" }}}
" Essential:   sets up whitespace visibility as per the filetype {{{
  augroup whitespace
    au!
    au filetype ghmarkdown,textile,text,rst setl nolist
    au filetype coffee,javascript setl listchars=trail:·,extends:#,nbsp:·
  augroup end
" }}}
" Essential:   turns on spell checking and automatic wrap on text files {{{
  augroup text_files
    au!
    au filetype ghmarkdown,textile,rst setl wrap wrapmargin=2
    au filetype ghmarkdown             setl formatoptions+=w
    au filetype ghmarkdown,textile,rst setl formatoptions+=qat
    au filetype ghmarkdown,textile,rst setl formatoptions-=cro
  augroup end
" }}}
" Essential:   warns when text width exceeds predefined width in certain file types {{{
  augroup exceeded_text_width
    au!
    au filetype python match ErrorMsg '\%>80v.\+'
    au filetype rst    match ErrorMsg '\%>74v.\+'
  augroup end
" }}}
" Essential:   has make programs defined for certain languages that does the heavy work {{{
  " Note: Dispatch does not support filename modifiers like: `%<`.
  "       Instead, use: `%:r`
  Plugin 'tpope/vim-dispatch'

  " Press <F6> to run the make command.
  " To check output, open QuickFix with `<leader>qf` or `:copen`
  nnoremap <F5> :Dispatch<CR>

  augroup make_programs
    au!
    au filetype php setl makeprg=php\ -l\ %    " linting
    au filetype rst setl makeprg=rst2html.py\ %\ /tmp/%:r.html\ &&\ open\ /tmp/%:r.html

    " Note: for markdown, simply, open the file in Chrome, which uses an
    " extension to render this markdown file. Sweet and simple.
    " au filetype ghmarkdown setl makeprg=rdiscount\ %\ >\ /tmp/%:r.html\ &&\ open\ /tmp/%:r.html
    au filetype ghmarkdown let &l:makeprg = s:open_with_browser("%:p", 0)

    " allow the following files to run themselves when <F6> is pressed.
    au filetype sh,bash,zsh setl makeprg=chmod\ +x\ %:p\ &&\ %:p
    au BufRead,BufEnter *.{rb,py,php,js} if executable(expand("%:p")) &&
          \ ( &makeprg == "make" ) | setl makeprg=%:p | endif

    " TODO: use a minifier as a make program for CSS & JS files
  augroup end
" }}}
" Essential:   provides documentation for certain languages via 'K' key {{{
  Plugin 'Keithbsmiley/investigate.vim'
  map K :call investigate#Investigate()<CR><CR>

  let g:investigate_use_dash=1
  " NOTE: This does not work at the moment, as 'open' encodes the URL wrongly.
  " map docs for the following languages to http://devdocs.io
  " for fs in [ 'c', 'cpp', 'css', 'django', 'go', 'haskell', 'html',
  "           \ 'javascript', 'php', 'python', 'ruby', 'rails' ]
  "   execute( 'let g:investigate_url_for_'.fs.'="http://devdocs.io/#q='.fs.' ^s"')
  " endfor
  " let g:investigate_url_for_coffee = 'http://devdocs.io/#q=coffeescript ^s'

  augroup documentor
    au!

    " appropriately use rails docs when inside a rails buffer
    au User Rails silent! let g:investigate_syntax_for_ruby="rails"
    au BufLeave *.rb silent! let g:investigate_syntax_for_ruby="ruby"

    " vim has additional help available via 'gK' mapping
    au filetype vim silent! nmap gK :let g:investigate_use_url_for_vim = 1<CR>
          \ :call investigate#Investigate()<CR><CR>
          \ :let g:investigate_use_url_for_vim = 0<CR>
  augroup end
" }}}
" " Essential:   supports CODE LINTING (error-checking) for many languages {{{
  Plugin 'neomake/neomake'
  autocmd! BufWritePost * Neomake
"   Plugin 'scrooloose/syntastic'
"   let g:syntastic_check_on_open            = 1
"   let g:syntastic_aggregate_errors         = 0
"   let g:syntastic_auto_jump                = 2
"   let g:syntastic_enable_signs             = 1
"   let g:syntastic_auto_loc_list            = 2
"   let g:syntastic_error_symbol             = '✗'
"   let g:syntastic_warning_symbol           = '⚠'
"   let g:syntastic_style_error_symbol       = '☢'
"   let g:syntastic_style_warning_symbol     = '☢'
"   let g:syntastic_always_populate_loc_list = 1
"   let g:syntastic_enable_balloons          = 1
"   let g:syntastic_enable_highlighting      = 1
"   let g:syntastic_id_checkers              = 1
"   " list of available checkers:
"   " https://github.com/scrooloose/syntastic/wiki/Syntax-Checkers
"   " let g:syntastic_python_checkers  = ['flake8']
"   " let g:syntastic_ruby_checkers  = ['mri', 'rubocop']
"   " let g:syntastic_ruby_rubocop_exec = expand("$RBENV_ROOT/shims/rubocop-no-warning")
"   let g:syntastic_mode_map = { "mode": "passive",
"                               \ "active_filetypes": ["ruby", "php", "python"],
"                               \ "passive_filetypes": ["html"] }
"   function! ToggleErrors()
"       let old_last_winnr = winnr('$')
"       lclose
"       if old_last_winnr == winnr('$')
"           " Nothing was closed, open syntastic error location panel
"           Errors
"       endif
"   endfunction
"   nnoremap <silent> <leader>tl :<C-u>call ToggleErrors()<CR>
"   " enable integration with airline
"   let g:airline#extensions#syntastic#enabled = 1

"   " " haskell
"   " FIXME: move this into Syntastic itself?
"   " " Haskell post write lint and check with ghcmod
"   " " $ `cabal install ghcmod` if missing and ensure
"   " " ~/.cabal/bin is in your $PATH.
"   " if !executable("ghcmod")
"   "   autocmd BufWritePost *.hs GhcModCheckAndLintAsync
"   " endif
" " }}}
" }}}
" Language Specific:                                                 {{{
" Mappings:    HTML:               creates folds using tags {{{
  nnoremap <leader>ft Vatzf
" }}}
" Specialize:  HTML:               easily escape or unescape HTML {{{
  Plugin 'skwp/vim-html-escape'
  " plugin mappings: <leader>he => escape | <leader>hu => unescape
" }}}
" Personalize: Ruby: Rails:        persist ctags when we move inside gem directories {{{
  augroup gem_ctags
    au!
    au BufEnter *.rb setl tags+=$RBENV_ROOT/versions/*/lib/ruby/gems/*/gems/*/tags
    au BufLeave *.rb setl tags-=$RBENV_ROOT/versions/*/lib/ruby/gems/*/gems/*/tags
  augroup END
" }}}
" Personlize: Ruby: Rails:         has command to quickly run specs {{{
" NOTE: this depends on vim-rspec plugin
  function! RunSpecs(...)
    let l:inside_app   = expand("%:h") =~ "app"
    let l:is_spec_file = expand("%:h") =~ "spec"
    if l:is_spec_file
      let l:path = expand("%")
    else
      let l:path = "spec/" . expand("%:h:t") . "/" . expand("%:t:r:r:r:r:r") . "_spec.rb"
      let l:path = substitute(l:path, "_spec_spec.rb", "_spec.rb", "g")
    end
    if filereadable(l:path)
      let l:path = a:0 && !empty(a:1) ? fnamemodify(l:path, a:1) : l:path
      let l:path = a:0 < 2 || empty(a:2) || l:inside_app ? l:path : l:path . a:2
      echo "Running specs: " . l:path
      execute substitute(g:rspec_command, "{spec}", l:path, "g")
    else
      echohl WarningMsg | echo "No such file found: " . l:path | echohl None
    endif
  endfunction
  let g:rspec_runner = "os_x_iterm2"
  if g:is_gui
    let g:rspec_command = 'Dispatch bundle exec bin/rspec {spec}'
  else
    let g:rspec_command = 'call VimuxRunCommand(" bin/rspec {spec}")'
  endif
  map <Leader>rsf :call RunSpecs()<CR>
  map <Leader>rsn :call RunSpecs("", ":" . line("."))<CR>
  map <Leader>rsl :call RunLastSpec()<CR>
  map <Leader>rsa :call RunSpecs(":h:h")<CR>
  map <Leader>rsg :call RunSpecs(":h")<CR>
" }}}
" Specialize:  Ruby:               has refactoring support for ruby code {{{
  Plugin 'ecomba/vim-ruby-refactoring'
" }}}
" Specialize:  Markdown & Textile: render YAML front matter as comments {{{
  augroup yaml_front_matter
    au!
    au filetype ghmarkdown,textile syntax region frontmatter start=/\%^---$/ end=/^---$/
    au filetype ghmarkdown,textile highlight link frontmatter Comment
  augroup end
" }}}
" Specialize:  VIM:                binds <F6> to open plugin's Github URL in browser {{{
  " Test it here:   ' ''' ' \"''" \" '' \"' Plugin 'nikhgupta/dotfiles' ''''''"
  " or, here: callPluginFunction 'some/asd'
  " FIXME: use regex and should also be able to open vim-scripts repos
  " Function: parses line containing a plugin, and opens it in browser {{{
  function! VimFindPluginName(line, delimiter)
    let segments = split(a:line, a:delimiter)
    let seg_len  = len(segments)
    for seg in segments
      let index = index(segments, seg)
      if ( index + 1 < seg_len ) && ( seg =~ "Plugin " || seg =~ "Bundle " )
        return segments[index + 1]
      endif
    endfor
  endfunction
  function! VimPluginBrowser(line)
    let plugin = VimFindPluginName(a:line, "'")
    if empty(plugin) | let plugin = VimFindPluginName(a:line, '"') | endif
    if empty(plugin)
      echom 'Could not find a plugin definition on this line.'
    else
      execute(":OpenURL https://github.com/" . plugin)
    endif
  endfunction
  " }}}
  augroup vim_plugin_browser
    au!
    au filetype vim noremap <silent> <buffer> <F6>
          \ <Esc>:call VimPluginBrowser(getline('.'))<CR>
  augroup end
" }}}
" Mappings:    VIM:                quickly, edit or source the vim configuration {{{
  " edit the vimrc file
  nmap <leader>e. :vs<CR>:e $MYVIMRC<CR>
  " source the current file
  nmap <leader>bs :source %<CR>:set foldenable<CR>:e!<CR>
  " source a visual range
  vmap <leader>bs y:@"<CR>:echo 'Sourced the selected range.'<CR>
" }}}
" Mappings:    Help:               quickly navigate the help window {{{
  augroup help_window
    au!
    au filetype help nnoremap <buffer><cr> <c-]>
    au filetype help nnoremap <buffer><bs> <c-T>
    au filetype help nnoremap <buffer>q :q<CR>
  augroup end
" }}}
" Specialize: Elixir {{{
  Plugin 'elixir-lang/vim-elixir'
  Plugin 'slashmili/alchemist.vim'
  Plugin 'c-brenn/phoenix.vim'
  Plugin 'tpope/vim-projectionist'
  let g:alchemist_tag_disable = 1
" }}}
" }}}
" Security:                                                          {{{
" Recommend:   rejects modelines {{{
  set nomodeline                  " disable mode lines (security measure)
" }}}
" Recommend:   rejects per directory editor configuration {{{
  set noexrc                      " disble per-directory .vimrc files
  set secure                      " disable unsafe commands in them
" }}}
" Advanced:    encryption support {{{
" TODO: revisit
  " https://coderwall.com/p/hypjbg
  if exists("&cryptmethod") | set cryptmethod=blowfish | endif
" }}}
" }}}
" Terminal:                                                          {{{
" Essential:   integrates with the user's login shell {{{
  " NOTE: DO NOT ENABLE INTERACTIVE SHELL OR TERMINAL VIM WILL SUSPEND ITSELF.
  " NOTE: For this reason, important environment variables, rbenv initialization,
  "       etc. must be placed inside ~/.zprofile, so that VIM can read them.
  if !g:is_windows
    if !empty('$SHELL')
      set shell=$SHELL\ -l
    elseif executable('zsh')
      set shell=zsh\ -l               " use a ZSH login shell
    elseif executable('bash')
      set shell=bash\ -l              " use a Bash login shell
    else
      set shell=/bin/sh
    endif
  endif
  Plugin 'Shougo/vimshell.vim'
" }}}
" Expected:    uses a faster tty (terminal) & sets it title as per the file {{{
  set title                         " change the terminal's title
  set ttyfast                       " always use a fast terminal
" }}}
" Tweak:       sets appropriate terminal colors for the terminal {{{
  " set appropriate terminal colors
  " if &t_Co > 2 && &t_Co < 16
  "   set t_Co =16
  " elseif &t_Co > 16
  "   set t_Co =256
  " endif
" }}}
" Essential:   adds support to run shell commands and capture output in a buffer {{{
  Plugin 'sjl/clam.vim'
" }}}
" Advanced:    adds support for TMux {{{
  Plugin 'benmills/vimux'
  Plugin 'christoomey/vim-tmux-navigator'
  let g:VimuxUseNearestPane = 1
  let g:VimuxOrientation = "h"
  let g:VimuxPromptString = "[ViMux] § "
  let g:VimuxHeight = "40"

  " open/close a new tmux pane
  map <leader>vo :call VimuxOpenRunner()<CR>
  map <leader>vq :VimuxCloseRunner<CR>

  " prompt for a command to be run async / run last command executed
  map <leader>v! :VimuxPromptCommand<CR>
  map <leader>vp :VimuxPromptCommand<CR>
  map <leader>vl :VimuxRunLastCommand<CR>

  " inspect, interrupt or zoom a vimux runner pane (<prefix>z to zoom out)
  " FIXME: this produces errors since no active Vimux window is present
  map <leader>vi :VimuxInspectRunner<CR>
  map <leader>vc :VimuxInterruptRunner<CR>
  map <Leader>vz :VimuxZoomRunner<CR>

  " run special commands within a tmux pane
  map <silent> <leader>vx :VimuxRunCommand("clear")<CR>
  map <silent> <leader>vm :VimuxRunCommand(expand(&makeprg))<CR>
  map <silent> <leader>vr :VimuxRunCommand("chmod +x " . expand("%:p:.") . " && " . expand("%:p"))<CR>

  " tSlime replacement:
  function! VimuxSlime()
    call VimuxSendText(@v)
    call VimuxSendKeys("Enter")
  endfunction
  " If text is selected, save it in the v buffer and send that buffer it to tmux
  vmap <leader>vs "vy:call VimuxSlime()<CR>
  " Select current paragraph and send it to tmux
  nmap <leader>vP vip<leader>vs<CR>
" }}}
" }}}

" Git Workflow:                                                      {{{
" Specialize:  adds support for running git commands from within the editor {{{
  Plugin 'tpope/vim-fugitive'
" }}}
" " Specialize:  displays git diff in sign column, and easily add hunks for staging {{{
"   Plugin 'airblade/vim-gitgutter'
"   " enable gitgutter by default
"   let g:gitgutter_enabled = 1
"   " but do not display signs by default
"   let g:gitgutter_signs = 0
"   " ignore whitespace
"   let g:gitgutter_diff_args = '-w'
"   " use the raw grep command
"   let g:gitgutter_escape_grep = 1
"   " let vim be snappier - don't lag.
"   let g:gitgutter_realtime = 0
"   let g:gitgutter_eager = 0

"   " remap mappings
"   let g:gitgutter_map_keys = 0
"   nmap ]h <Plug>GitGutterNextHunk<Plug>GitGutterPreviewHunk
"   nmap [h <Plug>GitGutterPrevHunk<Plug>GitGutterPreviewHunk
"   nmap <leader>hs  <Plug>GitGutterStageHunk
"   nmap <leader>hr  <Plug>GitGutterRevertHunk
"   nmap <leader>tgg :GitGutterSignsToggle<CR>
" " }}}
" Specialize:  enables support to manage Github Gists from the editor {{{
  Plugin 'mattn/webapi-vim'
  Plugin 'mattn/gist-vim'
  let g:gist_clip_command = 'pbcopy'
  let g:gist_detect_filetype = 1
  let g:gist_open_browser_after_post = 1
  let g:gist_post_private = 0
  let g:gist_get_multiplefile = 1
  let g:gist_show_privates = 1
  let g:github_user = $GITHUB_USER
  let g:github_token = $GITHUB_TOKEN
  let g:snips_author = "$NAME <$EMAIL>"
" }}}
" Specialize:  gitk like functionality inside the editor {{{
  Plugin 'gregsexton/gitv'
" }}}
" Specialize:  highlights conflict markers & provides a way to jump to them {{{
  match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'  " highlight conflict markers

  " shortcut to jump to next conflict marker
  nmap <silent> <leader>co /^\(<\\|=\\|>\)\{7\}\([^=].\+\)\?$<CR>
  " nmap <silent> <leader>co /\v^[<\|=>]{7}( .*\|$)<CR>
" }}}
" Specialize:  git commit messages have spell check enabled, and text width of 72 chars {{{
  augroup git_files
    au!
    autocmd BufRead,BufNewFile GHI_* set ft=gitcommit
    autocmd FileType gitcommit setlocal spell textwidth=72
  augroup end
" }}}
" }}}
" File Navigation:                                                   {{{
" Expected:    make <tab> completion for files/buffers act like bash {{{
  set wildmenu
  set wildmode=list:longest,full      " show a list when pressing tab, then longest common part and then full name.
  " set wildignore+=*/vendor/*          " stuff to ignore when tab completing ...
  set wildignore+=*/.hg/*,*/.svn/*
  set wildignore+=*vim/backups*       " ...
  set wildignore+=*/smarty/*          " ...
  " set wildignore+=*/node_modules/*    " ...
  set wildignore+=*/.sass-cache/*     " ...
  set wildignore+=*/tmp/*,tmp/**      " ...
  set wildignore+=*/out/**,log/**     " ... phew!!
  " file suffixes that can be safely ignored for file name completion
  set suffixes+=.swo,.d,.info,.aux,.log,.dvi,.pdf,.bin,.bbl,.blg,.DS_Store,.class,.so
  set suffixes+=.brf,.cb,.dmg,.exe,.ind,.idx,.ilg,.inx,.out,.toc,.pyc,.pyd,.dll,.zip
  set suffixes+=.gem,.pdf,.avi,.mkv,.psd
  " set suffixes+=.png,.jpg,.gif
" }}}
" Component:   provides a fuzzy finder for files, buffers, tags, etc. {{{
  Plugin 'kien/ctrlp.vim'
  " notes:
  "   - when CtrlP window is open:
  "   : f5 will clear the CtrlP cache (useful if you add new files during the session)
  "   : <C-f> & <C-b> will cycle between CtrlP modes
  "   : Press <c-d> to switch to filename only search instead of full path.
  "   : Press <c-r> to switch to regexp mode.
  "   : Use <c-j>, <c-k> or the arrow keys to navigate the result list.
  "   : Use <c-t> or <c-v>, <c-x> to open the selected entry in a new tab or in a new split.
  "   : Use <c-n>, <c-p> to select the next/previous string in the prompt's history.
  "   : Use <c-y> to create a new file and its parent directories.
  "   : Use <c-z> to mark/unmark multiple files and <c-o> to open them.
  " Set no max file limit
  let g:ctrlp_max_files = 0
  " Ignore files matching the following patterns
  let g:ctrlp_custom_ignore = '\.git$\|\.hg$\|\.svn$'
  " Store cache in this directory
  let g:ctrlp_cache_dir = expand("~/.vim") . "/tmp/cache/ctrlp"
  " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  if executable("ag") | let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""' | endif
  if executable("pt") | let g:ctrlp_user_command = 'pt %s -l --nocolor -g ""' | endif
  " switch between buffers, easily.
  " disabling movement between buffers, because of this :)
  map <C-b> :CtrlPBuffer<CR>
  " Search from current directory instead of project root
  map <C-o> :CtrlP %:p:h<CR>
  nnoremap <leader>. :CtrlPTag<cr>
" }}}
" Upgrade:     provides a feature-rich file explorer in a sidebar {{{

  " Stop fucking netrw
  let g:netrw_silent = 1
  let g:netrw_quiet  = 1
  " let g:loaded_netrw = 1          " prevents loading of netrw, but messes 'gx'
  " let g:loaded_netrwPlugin = 1    " ^ ..same.. and therefore, commented

  Plugin 'scrooloose/nerdtree'
  Plugin 'jistr/vim-nerdtree-tabs'

  let NERDTreeWinPos     = "left"    " nerdtree should appear on left
  let NERDTreeWinSize    = 25        " nerdtree window must be 30 char wide
  let NERDTreeDirArrows  = 1         " display fancy arrows instead of ASCII
  let NERDTreeMinimalUI  = 0         " I don't like the minimal UI, nerdtree!
  let NERDTreeStatusLine = -1        " do not use the default status line
  let NERDTreeHighlightCursorline=1  " highlight the current line in tree

  let NERDTreeShowFiles         = 1  " show files as well as dirs
  let NERDTreeShowHidden        = 1  " show hidden files, too.
  let NERDTreeShowBookmarks     = 1  " oh, and obvously, the bookmarks, too.
  let NERDTreeCaseSensitiveSort = 1  " sorting of files should be case sensitive
  let NERDTreeRespectWildIgnore = 1  " ignore files ignored by `wildignore`

  let NERDTreeChDirMode         = 2  " change CWD when tree root is changed
  let NERDTreeMouseMode         = 2  " use single click to fold/unfold dirs
  let NERDTreeQuitOnOpen        = 0  " do not quit on opening a file from tree
  let NERDTreeAutoDeleteBuffer  = 1  " delete buffer when deleting the file
  let NERDTreeBookmarksFile     = expand("~/.vim") . "/tmp/bookmarks"

  let g:nerdtree_tabs_open_on_gui_startup=0
  let g:nerdtree_tabs_open_on_console_startup=0

  " Sort NERDTree to show files in a certain order
  let NERDTreeSortOrder = [ '\/$', '\.rb$', '\.php$', '\.py$',
        \ '\.js$', '\.json$', '\.css$', '\.less$', '\.sass$', '\.scss$',
        \ '\.yml$', '\.yaml$', '\.sh$', '\..*sh$', '\.vim$',
        \ '*', '.*file$', '\.example$', 'license', 'LICENSE', 'readme', 'README',
        \ '\.md$', '\.markdown$', '\.rdoc$', '\.txt$', '\.text$', '\.textile$',
        \ '\.log$', '\.info$' ]

  " Don't display these kinds of files
  let NERDTreeIgnore = [ '\.pyc$', '\.pyo$', '\.py\$class$', '\.obj$', '\.o$',
        \ '\.so$', '\.egg$', '^\.git$', '^\.hg$', '^\.svn$', '^\.DS_Store',
        \ '\.png$', '\.jpg$', '\.jpeg$', '\.bmp$', '\.svg$', '\.gif$',
        \ '\.zip$', '\.gz$', '\.lock$', '\.swp$', '\.bak$', '\~$' ]

  " mappings
  nmap <leader>ntf <leader>nto<C-w>p:NERDTreeFind<CR>
  nmap <leader>ntc :NERDTreeClose<CR>
  nmap <leader>nto :NERDTreeFocus<CR>:vertical resize 25<CR>
  " nmap <Leader>ntt :NERDTreeTabsToggle<CR>
  " nmap <Leader>tnt :NERDTreeTabsToggle<CR>
" }}}
" }}}
" Search And Replace:                                                {{{
" Essential:   has built-in smart search feature, which searches as you type {{{
  set ignorecase                  " makes searches ignore case
  set smartcase                   " if pattern has uppercase, be case-sensitive
  set wrapscan                    " search continues after the end of file
  set magic                       " use magic mode when searching/replacing
  set gdefault                    " search/replace globally (on a line) by default
  set incsearch                   " show search matches as you type
  if g:is_gui || &t_Co > 2 | set hlsearch | endif
  " clears the search register
  nmap <silent> <leader><cr> :nohlsearch<CR>
  Plugin 'vim-scripts/IndexedSearch'
" }}}
" Expedite:    allows '*' or '#' keys to search for current word in normal or visual modes {{{
  Plugin 'nelstrom/vim-visual-star-search'
" }}}
" Expedite:    allows replacing multiple variants of a word in a single go {{{
  " Supports converting to and from snake_case, camelCase, MixedCase & UPPER_CASE
  Plugin 'tpope/vim-abolish'
" }}}
" Upgrade:     prefers 'silver-searcher' over 'ack' for searching, when possible {{{
  if executable('pt')
    Plugin 'rking/pt.vim'
    let g:ptprg='pt --vimgrep -S'
    set grepprg=pt\ --vimgrep\ -S
    nnoremap <leader>a :Pt <Space>
  elseif executable('ag')
    Plugin 'rking/ag.vim'
    let g:agprg='ag --vimgrep -S'
    set grepprg=ag\ --vimgrep\ -S
    nnoremap <leader>a :Ag <Space>
  elseif executable('ack')
    Plugin 'mileszs/ack.vim'
    nnoremap <leader>a :Ack --smart-case<Space>
  endif
" }}}
" Upgrade:     pulsate the line when jumping to search term, and center the window over it {{{
  " Function: Pulsate the line containing the cursor {{{
  function! PulseCursorLine()
    let current_window = winnr()

    windo set nocursorline
    execute current_window . 'wincmd w'

    setlocal cursorline

    redir => old_hi
    silent execute 'hi CursorLine'
    redir END
    let old_hi = split(old_hi, '\n')[0]
    let old_hi = substitute(old_hi, 'xxx', '', '')

    hi CursorLine guibg=#3a3a3a
    redraw
    sleep 20m

    hi CursorLine guibg=#4a4a4a
    redraw
    sleep 30m

    hi CursorLine guibg=#3a3a3a
    redraw
    sleep 30m

    hi CursorLine guibg=#2a2a2a
    redraw
    sleep 20m

    execute 'hi ' . old_hi

    windo set cursorline
    execute current_window . 'wincmd w'
  endfunction
  " }}}
  nnoremap <silent> n   n:call PulseCursorLine()<cr>zz
  nnoremap <silent> N   N:call PulseCursorLine()<cr>zz
  nnoremap <silent> *   *:call PulseCursorLine()<cr>zz
  nnoremap <silent> #   #:call PulseCursorLine()<cr>zz
  nnoremap <silent> g* g*:call PulseCursorLine()<cr>zz
  nnoremap <silent> g# g#:call PulseCursorLine()<cr>zz
" }}}
" Mappings:    display lines with keyword under cursor and ask to jump on one {{{
  " FIXME: when quitting from this command via <Esc>, it takes us to the first
  " match, instead of keeping the cursor in place.
  nmap <Leader>fs [I:let nr = input("Which one: ")<Bar>exe "normal " . nr ."[\t"<CR>
" }}}
" Mappings:    pull word under cursor into LHS of a substitute (for quick search and replace) {{{
  nmap <leader>fr :%s#\<<C-r>=expand("<cword>")<CR>\>#
" }}}
" }}}
" Undo Redo And Repeat:                                              {{{
" Essential:   has built-in persisting undo & redo, in branched form {{{
" Explaination: Persistence here means that your undo & redo data will be
" available even when you close the file, and try to edit it later.
  if has('persistent_undo')
    set undofile                  " have a long persisting undo data
    set undolevels=1000           " Maximum number of changes that can be undone
    set undoreload=10000          " Maximum number lines to save for undo on a buffer reload
    set undodir=~/.vim/tmp/undo,/tmp
  endif
" }}}
" Specialize:  allows traversing the undo/redo history as a graphical tree {{{
  Plugin 'sjl/gundo.vim'

  " toggle gundo window
  nnoremap <leader>tgu :GundoToggle<CR>
" }}}
" Upgrade:     allows repeat operator (".") to work with plugins, too {{{
  " supports plugins namely: commentary, surround, abolish, unimpaired
  Plugin 'tpope/vim-repeat'
" }}}
" Expected:    brings the cursor back when repeat command has been used {{{
  nmap . .`[
" }}}
" Expected:    allows using the repeat operator with visual selection {{{
  " see: http://stackoverflow.com/a/8064607/127816
  vnoremap . :normal .<CR>
" }}}
" }}}
" Clipboard And Yanking:                                             {{{
" Personalize: allows turning on paste mode with '<F2>' key {{{
  set pastetoggle=<F2>
" }}}
" Expedite:    allows pasting code easily, formats it, and reselects it for quick alignment {{{
  " function: paste using paste mode {{{
  function! PasteWithPasteMode(keys)
    if &paste
      execute("normal " . a:keys)
    else
      " Enable paste mode and paste the text, then disable paste mode.
      set paste
      execute("normal " . a:keys)
      set nopaste
    endif
  endfunction
  " }}}

  nnoremap <silent> <leader>p :call PasteWithPasteMode('p')<CR>`[v`]=`[v`]
  nnoremap <silent> <leader>P :call PasteWithPasteMode('P')<CR>`[v`]=`[v`]
" }}}
" Essential:   do share clipboard between editor and operating system {{{
  if g:is_nix && has('unnamedplus')
    set clipboard=unnamedplus,unnamed      " On Linux use + register for copy-paste
  else
    set clipboard+=unnamed                 " On mac and Windows, use * register for copy-paste
  endif
" }}}
" Specialize:  store and cycle through yanked text strings {{{
  Plugin 'maxbrunsfeld/vim-yankstack'
  if g:is_nix && has('unnamedplus')
    set clipboard=unnamedplus,unnamed      " On Linux use + register for copy-paste
  else
    set clipboard+=unnamed                 " On mac and Windows, use * register for copy-paste
  endif

  " do not use meta keys
  let g:yankstack_map_keys = 0
  " call yankstack#setup()                 " should happen after plugin indent?

  " for cycling what is pasted
  nmap <leader>pc <Plug>yankstack_substitute_older_paste

  " toggle YankStack window
  nnoremap <leader>tys :Yanks<CR>
" }}}
" Mappings:    reselects text that was just selected (or pasted) {{{
  nnoremap <leader>gv `[v`]
" }}}
" Expected:    pasting in visual mode replaces the selected text {{{
  vnoremap p <Esc>:let current_reg = @"<CR>gvdi<C-R>=current_reg<CR><Esc>
" }}}
" }}}
" Buffers Tabs And Windows:                                          {{{
" Recommend:   hide buffers instead of closing them {{{
  set hidden   " means that current buffer can be put to background without being written; and that marks and undo history are preserved.
" }}}
" Expected:    provides split editing behaviour, in an expected manner {{{
  set splitbelow                  " puts new split windows to the bottom of the current
  set splitright                  " puts new vsplit windows to the right of the current
  set equalalways                 " split windows are always of eqal size
  set switchbuf=useopen,split     " use existing buffer or else split current window
  set winheight=7               " squash splits or windows to a separator when minimized
  set winwidth=30               " squash splits or windows to a separator when minimized
  set winminheight=3              " squash splits or windows to a status bar only when minimized
  set winminwidth=12               " squash splits or windows to a separator when minimized
" }}}
" Expected:    resizes splits when the window is resized {{{
  augroup resize_splits
    au!
    au VimResized * :wincmd =
  augroup end
" }}}
" Advanced:    only opens 15 tabs when using '-p' CLI switch for the editor {{{
  set tabpagemax=15
" }}}
" Expedite:    Mappings: for easy control and navigation of windows {{{
  " resize splits/windows quickly
  map <C-W><C-=> <C-W>=
  map <C-W><C-M> <C-W>999+<C-W>999>

  " easy window navigation
  map <C-H> <C-W>h
  map <C-J> <C-W>j
  map <C-K> <C-W>k
  map <C-L> <C-W>l

  " easy window navigation with enlarged viewport (10 lines for other windows)
  map <C-W><C-H> <C-W>h<C-W><bar>
  map <C-W><C-J> <C-W>j<C-W>_
  map <C-W><C-K> <C-W>k<C-W>_
  map <C-W><C-L> <C-W>l<C-W><bar>
  map <C-W><C-T> <C-W>T
  " easily switch/rotate windows
  " for window layout: __|---
  map <C-W><space> <C-W>t<C-W>J<C-W>t<C-W>H

  " easily jump to a new buffer
  nnoremap <leader>el :buffers<CR>:buffer<Space>
  nnoremap <leader>e3 :e#
" }}}
" Expedite:    Mappings: open a new buffer with current file & switch to it {{{
  nnoremap <leader>wh <C-w>s
  nnoremap <leader>wv <C-w>v<C-w>l
" }}}
" Expedite:    Mappings: open a new buffer with previous file & switch to it {{{
  nnoremap <leader>ph :execute 'rightbelow split' bufname('#')<cr>
  nnoremap <leader>pv :execute 'leftabove vsplit' bufname('#')<cr>
" }}}
" Expected:    speeds up scrolling of the viewport slightly {{{
  nnoremap <C-e> 2<C-e>
  nnoremap <C-y> 2<C-y>
" }}}
" }}}
" Sessions:                                                          {{{
" Expected:    restores history, registers, etc. when a file is loaded {{{
  if has('viminfo')
    " ': Remember upto 500 files for which marks are remembered.
    " %: Save and restore the buffer list.
    " :: Remember upto 100 items in command-line history.
    " /: Remember upto 20  items in the search pattern history.
    " <: Remember upto 200 lines for each register.
    " f: Store file marks ('0 to '9 and 'A to 'Z)
    " Further, reading:  :h viminfo
    set viminfo='500,:100,@100,/20,f1,%,<200
  endif
" }}}
" Expected:    restores editor's window's size, as well {{{
  if has('mksession')
    set sessionoptions+=resize
  endif
" }}}
" Expected:    remembers a long history of commands and searches performed {{{
  set history=1000
" }}}
" Expected:    restore cursor position on opening a file {{{
  augroup restore_cursor
    au!
    autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$")
                          \ | exe "normal! g`\"" | endif
  augroup end
" }}}
" " Modernize:   automatically, saves and restores editor sessions {{{
"   " NOTE: vim-misc is required for vim-session
"   Plugin 'xolox/vim-misc'
"   Plugin 'xolox/vim-session'
"   let g:session_autoload = 'yes'
"   let g:session_autosave = 'yes'
"   " let g:session_default_overwrite = 1
"   let g:session_default_to_last = 1
"   " let g:session_command_aliases = 1

"   nnoremap <leader>QA :call SaveSessionWithPrompt()<CR>:qall<CR>
"   " Function: save session by prompting the user for a session name {{{
"   function! SaveSessionWithPrompt()
"     " guess name from current session, if any
"     let name = xolox#session#find_current_session()
"     let is_tab_scoped = xolox#session#is_tab_scoped()

"     " ask user for a session name, otherwise
"     if empty(name)
"       let default_name = ''
"       if g:session_default_name
"         let default_name = g:session_default_name
"       endif

"       call inputsave()
"       let name = input('save session? by what name? ', default_name)
"       call inputrestore()
"     endif

"     " use the default session name, otherwise
"     if empty(name) && g:session_default_name
"       let name = g:session_default_name
"     endif

"     " save the given session
"     if xolox#session#is_tab_scoped()
"       call xolox#session#save_tab_cmd(name, '!', 'SaveTabSession')
"     else
"       call xolox#session#save_cmd(name, '!', 'SaveSession')
"     endif

"   endfunction
"   " }}}
" " }}}
" }}}
" Utilities:                                                         {{{
" Expedite:    has helper commands to run simple unix commands, like `chmod` {{{
  Plugin 'tpope/vim-eunuch'
" }}}
" Expedite:    provides mappings to quickly toggle specific editor features {{{
  " TODO: remove mappings obsolete because of this plugin
  Plugin 'tpope/vim-unimpaired'
" }}}
" Mappings:    provides replaying a macro linewise on a visual selection {{{
  " note that, the macro must be recorded in the `v` register
  vnoremap <leader>qv :normal @v
" }}}
" " Expedite:    provides a way to learn VIM easily via recipes {{{
"   Plugin 'esneider/recipes.vim'
"   nnoremap <Leader>r :CtrlPRecipes<CR>
" " }}}
  Plugin 'irrationalistic/vim-tasks'

  let g:TasksMarkerBase = '☐'
  let g:TasksMarkerDone = '✔'
  let g:TasksMarkerCancelled = '✘'
  let g:TasksDateFormat = '%Y-%m-%d %H:%M'
  let g:TasksAttributeMarker = '@'
  let g:TasksArchiveSeparator = '＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿'

  augroup task_plugin
    au!
    autocmd BufNewFile,BufReadPost *.TODO,TODO,*.todo,*.todolist,*.taskpaper,*.tasks set filetype=tasks
  augroup end
" }}}
" Miscelleneous:                                                     {{{
" Recommend:   allows incr/decr with <C-x> & <C-a> for alphabets, numbers & hex {{{
  set nrformats-=octal            " do not treat octal as numbers
  set nrformats+=alpha            " but, allow inc/dec on alphabetical letters
" }}}
" Component:   scratchable buffer for scrappables {{{
  Plugin 'duff/vim-scratch'
  nmap <leader><tab> :Sscratch<CR><C-W>x<C-J>
" }}}
" Mappings:    toggles QuickFix window using '<leader>qf' {{{
  " Function: Quickly toggle in/out the QuickFix window {{{
  function! QFixToggle(forced)
    if exists("g:qfix_win") && a:forced == 0
      cclose
      unlet g:qfix_win
    else
      copen 10
      let g:qfix_win = bufnr("$")
    endif
  endfunction " }}}
  command! -bang -nargs=? QFix call QFixToggle(<bang>0)
  nmap <silent> <leader>qf :QFix<CR>
" }}}
" Mappings:    quickly, obfuscates the current buffer {{{
  nnoremap <F9> mzggg?G'z
" }}}
" Specialize:  has a command that shows the MD5 of the current buffer or range {{{
  command! -range Md5 :echo system('echo '.shellescape(join(getline(<line1>, <line2>), '\n')) . '| md5')
" }}}
" Specialize:  SimpleNote: note-taking via vim {{{
  Plugin 'mrtazz/simplenote.vim'
  let g:SimplenoteUsername=$SIMPLENOTE_USER
  let g:SimplenotePassword=$SIMPLENOTE_PASS
  let g:SimplenoteFiletype="markdown"
  let g:SimplenoteListHeight=30
" }}}
" }}}
" Abbreviations:                                                     {{{
  " auto-corrections for spellings
  " call SourceIfReadable('~/.vim/spell/autocorrect.vim')
  iabbr NG@  Nikhil Gupta
  iabbr WD@  Wicked Developers

  iabbr ng@  me@nikhgupta.com
  iabbr mg@  mestoic@gmail.com
  iabbr wd@  nikhil@wickeddevelopers.com

  iabbr ng/  http://nikhgupta.com/
  iabbr wd/  http://wickeddevelopers.com/
  iabbr gh/  http://github.com/
  iabbr ghn/ http://github.com/nikhgupta/

  iabbr nsig --<cr>Nikhil Gupta<cr>me@nikhgupta.com
  iabbr wsig --<cr>Nikhil Gupta<cr>nikhil@wickeddevelopers.com
" }}}
" Epilogue:                                                          {{{
  call SourceIfReadable("~/.gvimrc")
  call SourceIfReadable("~/.vimrc.local")

  " required by Vundle
  call vundle#end()               " required
  filetype plugin indent on       " enable detection, plugins and indenting in one step

  " install Plugins, if we just installed Vundle
  if iCanHazVundle == 0
    echo "Installing Plugins, please ignore key map error messages"
    :PluginInstall
  endif

  " TrueColor support
  if &term =~# '^screen'
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
  endif
  colorscheme nova
  " let g:gruvbox_contrast_dark = "soft"
  " colorscheme gruvbox
  " set bg=dark
  " colors dracula
  " let g:airline_theme='onehalfdark'
  " colorscheme onehalflight
  " set bg=light
  " if g:is_gui
  "   colorscheme solarized
  " else
  "   colorscheme solarized
  "   set bg=light
     " hi Folded term=standout ctermfg=248 ctermbg=237 guifg=#999999 guibg=#d2d2d2
     " hi! default link NERDTreeDirSlash NonText
  " endif
" }}}
